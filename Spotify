Design Music Streaming Like Spotify:

What are we building?
A platform where users can:
* Search and play songs, albums, and playlists
* Get recommendations
* Follow artists/friends
* Have free (ads) & premium (no ads, offline) tiers
* Stream globally with low latency

High-Level Architecture:

Control Plane (metadata + logic)
* Handles user requests like searching songs, loading playlists, login, payments.
* Services:
    * Catalogue Service â†’ songs, albums, artistsâ€™ info
    * Playlist/Library Service â†’ userâ€™s playlists, likes
    * Search Service â†’ powered by Elasticsearch
    * Recommendation Service â†’ suggests songs
    * User Service â†’ login, subscription tier, preferences
    * Playback Service â†’ checks if user is allowed to play (premium/free, region, rights)


Data Plane (actual music streaming)
* Songs are stored in object storage (S3/GCS).
* Transcoded to multiple bitrates (96, 160, 320 kbps).
* Delivered via CDN using HLS/DASH format.
* Protected with DRM (so downloads canâ€™t be pirated).


Data Model (simplified)
* Users: id, name, subscription_type (free/premium), country
* Artists: id, name, genres
* Albums: id, artist_id, release_date
* Tracks: id, album_id, duration, audio_url(s), available_regions
* Playlists: id, owner_id, title, tracks[]
* Likes/History: user_id, track_id


Client  -> API Gateway    ->  Control Plane (All microservices)     ->  Object Storage ->   CDN    -> client (Plays chunk via HLS)

How to explain this diagram in an interview:
* Clients (mobile/web/desktop) talk to APIs for metadata (search, playlists, recommendations).
* Control Plane = services that handle user data, playlists, recommendations, and entitlements.
* Playback Orchestrator is the brain before streaming â†’ checks subscription, geo, rights, then gives back a CDN manifest + DRM license.
* Data Plane = music files. Songs live in object storage, broken into chunks, distributed globally via CDN.
* Client plays chunks directly from CDN (fast, cheap).


Reliability
* Use multi-region deployment for APIs.
* Caches (Redis) for hot data (playlists, recommendations).
* If the recommendation service fails â†’ fallback to popular playlists.
* If CDN fails in a region â†’ reroute to the backup provider.

Scale Considerations
* Catalogue: millions of tracks, mostly read-heavy.
* Streaming: millions of concurrent users â†’ must go via CDN to reduce latency/cost.
* Search: autocomplete < 100 ms.
* Global Rights: track may not be available everywhere â†’ Playback Service enforces this.

Playback Flow
1. User clicks Play.
2. App calls Playback Service â†’ checks subscription, geo-restrictions, device rules.
3. If okay â†’ service returns a manifest (HLS/DASH URL) + DRM license.
4. Client fetches small audio chunks from CDN.
5. Heartbeats sent to backend (used for analytics + recommendations).


Recommendations (basic approach)
* Collect signals: plays, skips, likes, search queries.
* Offline jobs (Spark) train models â†’ collaborative filtering + content-based.
* Online system ranks candidates and shows home feed (e.g., â€œMade for Youâ€).


How will you handle millions of users streaming at the same time?
ðŸ‘‰ Answer:
* Use CDN for audio chunks (offload traffic from backend).
* Ensure 95%+ cache hit rate at CDN.
* Multi-bitrate streaming so each user adapts to the network.
* Backend only controls metadata, not audio delivery.

What about artists uploading content?
ðŸ‘‰ Answer:
* Content Ingestion Service:
    * Upload â†’ transcode into multiple bitrates â†’ DRM packaging â†’ CDN.
    * Metadata pushed into catalog + search index.
* Rights management ensures royalties tracked.


